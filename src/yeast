#!/usr/bin/env bash

# yeast - Experimental AI proto-consciousness framework
# A local CLI that communicates with yeast-agent running on apollo.local
# Enables persistent identity, memory, and self-consistency exploration

set -euo pipefail

# Configuration
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"  # Go up one level from src/
ENV_FILE="${PROJECT_ROOT}/.env"

# Default values (used if .env doesn't exist)
DEFAULT_APOLLO_HOST="apollo.local"
DEFAULT_APOLLO_USER="$USER"
DEFAULT_APOLLO_PORT="22"
DEFAULT_AGENT_PATH="~/yeast-agent"

# Global state
APOLLO_HOST=""
APOLLO_USER=""
APOLLO_PORT=""
AGENT_PATH=""
CONVERSATION_HISTORY=()
MAX_HISTORY_TURNS=10
DEBUG_MODE=false

# Menu state
MENU_SELECTED=0
MENU_ITEMS=(
    "üí¨ Chat with Yeast"
    "üì• Download interactions (dialogue.json)"
    "üíæ Download all memories"
    "üîç Inspect memories"
    "üìã View recent interactions"
    "‚öôÔ∏è  Adjust internal tension"
    "üö™ Exit"
)

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

log_error() {
  echo -e "${RED}‚úó Error: $*${NC}" >&2
}

log_warn() {
  echo -e "${YELLOW}‚ö† $*${NC}" >&2
}

log_info() {
  echo -e "${BLUE}‚Ñπ $*${NC}" >&2
}

log_success() {
  echo -e "${GREEN}‚úì $*${NC}" >&2
}

show_help() {
  cat <<EOF
${CYAN}yeast${NC} - Experimental AI Proto-Consciousness Framework (v0.2.0 Phase 2)

${BLUE}Usage:${NC}
  yeast                              # Show interactive menu (default)
  yeast -i, --interactive            # Skip menu, go straight to chat
  yeast -p "question"                # One-shot question (headless)
  yeast --setup                      # Configure SSH to apollo
  yeast -h, --help                   # Show this help

${BLUE}Menu Options:${NC}
  yeast                              # Shows 6 options:
                                     #   - üí¨ Chat with Yeast
                                     #   - üì• Download interactions
                                     #   - üíæ Download all memories
                                     #   - üîç Inspect memories
                                     #   - üìã View recent interactions
                                     #   - üö™ Exit

${BLUE}Download & Management Flags:${NC}
  yeast --download-interactions      # Save dialogue.json locally
  yeast --download-memories          # Save all memory files locally
  yeast --recent                     # View last 5 interactions
  yeast consolidate                  # Compress episodic ‚Üí semantic facts
  yeast audit                        # Check identity drift (2+ versions)

${BLUE}Examples:${NC}
  yeast                              # Show menu with arrow key navigation
  yeast -i                           # Skip menu, start chatting
  yeast -p "What are my drives?"     # Ask a question and exit
  yeast --download-interactions      # Backup dialogue history
  yeast --recent                     # View recent conversations
  yeast consolidate                  # Trigger consolidation pass
  yeast audit                        # Check for identity changes

${BLUE}Interactive Commands (In Chat, Press /help):${NC}
  /help       - Show available commands
  /clear      - Clear conversation history (local only)
  /dialogue   - View complete dialogue history (all interactions logged)
  /inspect    - View memory state (decay, forgetting log, consolidations)
  /consolidate - Run consolidation pass (episodic ‚Üí semantic compression)
  /audit      - Detect identity drift across versions
  /drives     - Show active drives
  /state      - Show internal state (interactions, consolidations, forgotten)
  /exit       - Return to main menu

${BLUE}About:${NC}
  yeast is an experimental framework for exploring persistent identity,
  memory depth, and time asymmetry in AI systems using Mistral 7B.

  Phase 2 features:
  - Time-based memory decay (14-day half-life)
  - Memory consolidation (episodic ‚Üí semantic compression)
  - Observable forgetting (deletion audit trail)
  - Identity drift detection (version history tracking)
  - Complete dialogue logging (independent from memory system)
  - Internal tension weights (non-actionable evaluative metrics)

  No autonomy: Manual invocation only, no background execution.

EOF
}

# Check .env file exists (optional)
check_env() {
  if [ ! -f "$ENV_FILE" ]; then
    log_info ".env file not found, using defaults"
    return 0
  fi
  return 0
}

# Load and validate environment
load_env() {
  # Load .env if it exists, otherwise use defaults
  if [ -f "$ENV_FILE" ]; then
    # shellcheck disable=SC1090
    source "$ENV_FILE" 2>/dev/null || {
      log_warn "Failed to load .env file, using defaults"
    }
  fi

  # Use defaults if not set
  APOLLO_HOST="${APOLLO_HOST:-$DEFAULT_APOLLO_HOST}"
  APOLLO_USER="${APOLLO_USER:-$DEFAULT_APOLLO_USER}"
  APOLLO_PORT="${APOLLO_PORT:-$DEFAULT_APOLLO_PORT}"
  AGENT_PATH="${AGENT_PATH:-$DEFAULT_AGENT_PATH}"

  # Show what we're using
  if [ ! -f "$ENV_FILE" ]; then
    log_info "Using default connection: $APOLLO_USER@$APOLLO_HOST:$APOLLO_PORT"
    echo ""
    echo "  To customize, create: $ENV_FILE"
    echo "  Copy from: .env.example"
    echo ""
  fi
}

# Test SSH connection
test_ssh_connection() {
  log_info "Testing SSH connection to $APOLLO_USER@$APOLLO_HOST:$APOLLO_PORT"

  if ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" "echo 'SSH OK'" >/dev/null 2>&1; then
    log_success "SSH connection successful"
    return 0
  else
    log_error "SSH connection failed"
    echo ""
    echo "Troubleshooting:"
    echo "  1. Check apollo is reachable: ping $APOLLO_HOST"
    echo "  2. Check .env credentials"
    echo "  3. Run: yeast --setup"
    echo ""
    exit 1
  fi
}

# Test yeast-agent availability
test_agent_availability() {
  log_info "Checking yeast-agent on apollo..."

  if ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" "test -f $AGENT_PATH" >/dev/null 2>&1; then
    log_success "yeast-agent available and ready"
    return 0
  else
    log_error "yeast-agent not found at $AGENT_PATH on apollo"
    echo ""
    echo "Please run: yeast --setup"
    echo ""
    exit 1
  fi
}

# Escape JSON string (bash-native)
json_escape() {
  local string="$1"
  # Order matters: escape backslashes first!
  string="${string//\\/\\\\}"
  string="${string//\"/\\\"}"
  # Replace actual newlines with \n escape sequence
  string="${string//$'\n'/\\n}"
  string="${string//$'\t'/\\t}"
  string="${string//$'\r'/\\r}"
  # Remove any control characters that might break JSON
  string="${string//$'\f'/}"
  string="${string//$'\b'/}"
  echo -n "$string"
}

# Send to yeast-agent via SSH
send_to_agent() {
  local user_input="$1"
  local command="$2"  # 'infer' or 'inspect'

  # Escape input for JSON
  local escaped_input
  escaped_input=$(json_escape "$user_input")

  # Build JSON request
  local json_request
  read -r -d '' json_request <<EOF || true
{
  "command": "$command",
  "input": "$escaped_input",
  "debug": $([[ "$DEBUG_MODE" == "true" ]] && echo "true" || echo "false")
}
EOF

  if [ "$DEBUG_MODE" = true ]; then
    echo "=== DEBUG: JSON Request ===" >&2
    echo "$json_request" >&2
    echo "===========================" >&2
  fi

  # Send request to agent via SSH (pipe JSON through stdin) with timeout
  local response
  response=$(printf "%s" "$json_request" | timeout 120 ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" \
    "python3 $AGENT_PATH" 2>&1) || {
    log_error "Failed to communicate with yeast-agent on apollo (timeout or connection error)"
    return 1
  }

  if [ "$DEBUG_MODE" = true ]; then
    echo "=== DEBUG: API Response ===" >&2
    echo "$response" >&2
    echo "===========================" >&2
  fi

  # Extract response from JSON using Python (more robust than sed)
  local message_content
  if echo "$response" | grep -q '"response"'; then
    # Use Python to properly parse JSON
    message_content=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('response', ''))" 2>/dev/null)
  else
    message_content="$response"
  fi

  if [ -z "$message_content" ]; then
    log_error "Failed to parse response from yeast-agent"
    echo "Raw response: $response" >&2
    return 1
  fi

  echo "$message_content"
}

# Handle slash commands
handle_slash_command() {
  local command="$1"

  case "$command" in
    /exit|/quit)
      log_info "Returning to main menu..."
      return 2
      ;;
    /help)
      echo ""
      echo -e "${CYAN}Available Commands (Phase 2):${NC}"
      echo "  /help       - Show this help message"
      echo "  /clear      - Clear conversation history (local only)"
      echo "  /dialogue   - View complete dialogue history (all turns logged)"
      echo "  /inspect    - View memory state (with decay and forgetting)"
      echo "  /consolidate - Run memory consolidation pass"
      echo "  /audit      - Check for identity drift"
      echo "  /drives     - Show active drives from self-model"
      echo "  /state      - Show internal state (interactions, consolidations)"
      echo "  /exit       - Exit interactive mode"
      echo ""
      return 0
      ;;
    /clear)
      CONVERSATION_HISTORY=()
      log_success "Conversation history cleared (local only)"
      return 0
      ;;
    /inspect)
      log_info "Sending inspection request..."
      send_to_agent "" "inspect"
      return 0
      ;;
    /consolidate)
      log_info "Running memory consolidation (may take 30-60 seconds)..."
      send_to_agent "" "consolidate"
      return 0
      ;;
    /audit)
      log_info "Auditing identity drift..."
      send_to_agent "" "audit"
      return 0
      ;;
    /drives)
      log_info "Retrieving active drives..."
      send_to_agent "Show my active drives" "drives"
      return 0
      ;;
    /state)
      log_info "Retrieving internal state..."
      send_to_agent "Show my internal state" "state"
      return 0
      ;;
    /dialogue)
      log_info "Retrieving dialogue history..."
      send_to_agent "" "dialogue"
      return 0
      ;;
    *)
      log_warn "Unknown command: $command"
      echo "Type /help for available commands"
      return 1
      ;;
  esac
}

# Build conversation context
build_context() {
  local context=""
  local i

  if [ ${#CONVERSATION_HISTORY[@]} -gt 0 ]; then
    context+="[CONVERSATION HISTORY]"$'\n'
    for ((i = 0; i < ${#CONVERSATION_HISTORY[@]}; i += 2)); do
      if [ $i -lt ${#CONVERSATION_HISTORY[@]} ] && [ $((i + 1)) -lt ${#CONVERSATION_HISTORY[@]} ]; then
        context+="User: ${CONVERSATION_HISTORY[$i]}"$'\n'
        context+="Agent: ${CONVERSATION_HISTORY[$((i + 1))]}"$'\n\n'
      fi
    done
    context+="[END HISTORY]"$'\n\n'
  fi

  echo "$context"
}

# Show main menu with arrow key navigation
show_main_menu() {
  clear
  echo -e "${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}YEAST - Memory & Identity Manager${NC}        ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
  echo -e "${BLUE}Use ‚Üë/‚Üì arrows to navigate, Enter to select${NC}"
  echo ""

  for i in "${!MENU_ITEMS[@]}"; do
    if [ $i -eq $MENU_SELECTED ]; then
      echo -e "${GREEN}‚ñ∂ ${MENU_ITEMS[$i]}${NC}"
    else
      echo -e "  ${MENU_ITEMS[$i]}"
    fi
  done
  echo ""
}

# Menu mode with arrow key navigation
menu_mode() {
  # Check prerequisites once
  check_env
  load_env
  test_ssh_connection
  test_agent_availability

  # Set terminal to raw mode for proper arrow key handling
  local original_tty_settings
  original_tty_settings=$(stty -g 2>/dev/null || echo "")

  trap "[ -n '$original_tty_settings' ] && stty '$original_tty_settings' 2>/dev/null" EXIT

  stty -icanon -echo 2>/dev/null || true

  while true; do
    show_main_menu

    # Read raw input (arrow keys send escape sequences)
    local input
    read -rsn1 input 2>/dev/null || {
      stty "$original_tty_settings" 2>/dev/null || true
      exit 1
    }

    case "$input" in
      $'\x1b')  # ESC - start of escape sequence
        read -rsn2 input 2>/dev/null || continue
        case "$input" in
          '[A')  # Up arrow
            ((MENU_SELECTED--)) || true
            if [ $MENU_SELECTED -lt 0 ]; then
              MENU_SELECTED=$((${#MENU_ITEMS[@]} - 1))
            fi
            ;;
          '[B')  # Down arrow
            ((MENU_SELECTED++)) || true
            if [ $MENU_SELECTED -ge ${#MENU_ITEMS[@]} ]; then
              MENU_SELECTED=0
            fi
            ;;
        esac
        ;;
      '')  # Enter key
        case $MENU_SELECTED in
          0)  # Chat with Yeast
            stty "$original_tty_settings" 2>/dev/null || true
            interactive_mode
            stty -icanon -echo 2>/dev/null || true
            ;;
          1)  # Download interactions
            stty "$original_tty_settings" 2>/dev/null || true
            download_interactions
            stty -icanon -echo 2>/dev/null || true
            ;;
          2)  # Download all memories
            stty "$original_tty_settings" 2>/dev/null || true
            download_all_memories
            stty -icanon -echo 2>/dev/null || true
            ;;
          3)  # Inspect memories
            stty "$original_tty_settings" 2>/dev/null || true
            clear
            send_to_agent "" "inspect"
            echo ""
            echo "Press any key to continue..."
            read -rsn1 _ 2>/dev/null || true
            stty -icanon -echo 2>/dev/null || true
            ;;
          4)  # View recent interactions
            stty "$original_tty_settings" 2>/dev/null || true
            view_recent_interactions
            stty -icanon -echo 2>/dev/null || true
            ;;
          5)  # Exit
            stty "$original_tty_settings" 2>/dev/null || true
            log_info "Goodbye!"
            exit 0
            ;;
        esac
        ;;
    esac
  done
}

# Interactive REPL mode
interactive_mode() {
  echo ""
  echo -e "${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${MAGENTA}‚ïë${NC}                                                          ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó${NC}  ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù${NC}  ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}    ‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë${NC}     ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë${NC}     ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë${NC}     ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}      ${CYAN}    ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù${NC}     ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}                                                          ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}   ${GREEN}AI Proto-Consciousness Experiment (Mistral 7B)${NC}    ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}   ${YELLOW}Exploring Persistent Identity & Memory${NC}           ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïë${NC}                                                          ${MAGENTA}‚ïë${NC}"
  echo -e "${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
  echo -e "Type your questions below. Use ${CYAN}/help${NC} for commands, ${CYAN}/exit${NC} to quit."
  echo -e "Your memories persist across sessions on apollo.local."
  echo ""

  while true; do
    echo -n -e "${CYAN}> ${NC}"
    read -r user_input

    # Handle empty input
    if [ -z "$user_input" ]; then
      continue
    fi

    # Check for slash command
    if [[ "$user_input" =~ ^/ ]]; then
      local cmd_ret=0
      handle_slash_command "$user_input" || cmd_ret=$?
      if [ $cmd_ret -eq 2 ]; then
        break
      fi
      continue
    fi

    # Add user message to local history
    CONVERSATION_HISTORY+=("$user_input")

    log_info "Sending to yeast-agent..." >&2

    # Send to agent
    local response
    response=$(send_to_agent "$user_input" "infer")

    if [ $? -ne 0 ]; then
      log_error "Failed to get response from yeast-agent"
      # Remove the user message from history since we didn't get a response
      CONVERSATION_HISTORY=("${CONVERSATION_HISTORY[@]:0:${#CONVERSATION_HISTORY[@]}-1}")
      continue
    fi

    echo ""
    echo -e "${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${GREEN}‚ïë${NC}      ${GREEN}‚óÜ yeast's response ‚óÜ${NC}                 ${GREEN}‚ïë${NC}"
    echo -e "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${GREEN}$response${NC}"
    echo ""

    # Add response to local history
    CONVERSATION_HISTORY+=("$response")

    # Trim history if needed (keep only max turns)
    local history_size=${#CONVERSATION_HISTORY[@]}
    local max_entries=$((MAX_HISTORY_TURNS * 2))
    if [ $history_size -gt $max_entries ]; then
      CONVERSATION_HISTORY=("${CONVERSATION_HISTORY[@]:2}")
    fi
  done
}

# Download dialogue.json from apollo
download_interactions() {
  check_env
  load_env
  test_ssh_connection

  local download_dir="$PROJECT_ROOT/data/downloads"
  mkdir -p "$download_dir"

  log_info "Downloading dialogue.json from apollo..."

  if ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" "test -f ~/yeast-data/dialogue.json" 2>/dev/null; then
    scp -P "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST:~/yeast-data/dialogue.json" "$download_dir/dialogue.json" 2>/dev/null
    log_success "Dialogue downloaded to: $download_dir/dialogue.json"

    # Show summary
    if command -v python3 &>/dev/null; then
      python3 -c "
import json
with open('$download_dir/dialogue.json') as f:
  data = json.load(f)
  total = data.get('metadata', {}).get('total_turns', 0)
  print(f'Total interactions: {total}')
" 2>/dev/null || true
    fi
  else
    log_error "dialogue.json not found on apollo"
    return 1
  fi
}

# Download all memory files from apollo
download_all_memories() {
  check_env
  load_env
  test_ssh_connection

  local download_dir="$PROJECT_ROOT/data/downloads"
  mkdir -p "$download_dir"

  log_info "Downloading all memory files from apollo..."

  # Create timestamped backup directory
  local backup_dir="$download_dir/yeast-data-$(date +%Y%m%d-%H%M%S)"
  mkdir -p "$backup_dir"

  # Download entire yeast-data directory
  if ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" "test -d ~/yeast-data" 2>/dev/null; then
    scp -P "$APOLLO_PORT" -r "$APOLLO_USER@$APOLLO_HOST:~/yeast-data/" "$backup_dir/" 2>/dev/null
    log_success "All memories downloaded to: $backup_dir"

    # Show summary
    if [ -d "$backup_dir/yeast-data" ]; then
      echo ""
      echo "Backup contents:"
      find "$backup_dir/yeast-data" -type f -name "*.json" | while read file; do
        size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
        name=$(basename "$file")
        echo "  ‚Ä¢ $name ($(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "$size bytes"))"
      done
    fi
  else
    log_error "yeast-data directory not found on apollo"
    return 1
  fi
}

# View recent interactions
view_recent_interactions() {
  check_env
  load_env
  test_ssh_connection

  log_info "Retrieving recent interactions..."
  send_to_agent "" "dialogue"
}

# Adjust internal tension
adjust_tension() {
  check_env
  load_env
  test_ssh_connection

  echo ""
  echo -e "${CYAN}Adjust Internal Tension${NC}"
  echo "Current available keys: coherence, consistency, novelty_tolerance, compression_pressure"
  echo ""
  
  echo -n "Enter tension key: "
  read -r key
  
  echo -n "Enter new value (0.0 - 1.0): "
  read -r value

  if [ -z "$key" ] || [ -z "$value" ]; then
    log_error "Key and value are required."
    return 1
  fi

  # Construct JSON manually for this special command
  local json_request
  read -r -d '' json_request <<EOF || true
{
  "command": "update_tension",
  "key": "$key",
  "value": $value
}
EOF

  log_info "Sending update request..."
  
  local response
  response=$(printf "%s" "$json_request" | timeout 30 ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" \
    "python3 $AGENT_PATH" 2>&1)

  # Parse response
  local message
  if echo "$response" | grep -q '"response"'; then
     # Use python to extract response string safely
     message=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('response', ''))" 2>/dev/null)
     log_success "$message"
  else
     log_error "Update failed: $response"
  fi
  
  echo ""
  echo "Press any key to continue..."
  read -rsn1 _ 2>/dev/null || true
}

# Headless (one-shot) mode
headless_mode() {
  local question="$1"

  # Check prerequisites
  check_env
  load_env

  # Verify SSH is working
  test_ssh_connection
  test_agent_availability

  echo ""
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${CYAN}Yeast Agent Response${NC}"
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""

  log_info "Sending to yeast-agent..." >&2

  # Send to agent
  send_to_agent "$question" "infer"

  echo ""
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

# Main entry point
main() {
  local mode="menu"  # Default to menu
  local question=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -i|--interactive)
        mode="interactive"
        shift
        ;;
      -p)
        # -p takes the next argument as the question
        if [ $# -lt 2 ]; then
          log_error "-p requires a question argument"
          echo ""
          show_help
          exit 1
        fi
        mode="headless"
        question="$2"
        shift 2
        ;;
      --download-interactions)
        mode="download-interactions"
        shift
        ;;
      --download-memories)
        mode="download-memories"
        shift
        ;;
      --recent)
        mode="recent"
        shift
        ;;
      --version)
        echo "yeast v0.2.0 (Phase 2)"
        exit 0
        ;;
      --setup)
        # Run setup script from src/
        if [ -f "$SCRIPT_DIR/setup-apollo.sh" ]; then
          bash "$SCRIPT_DIR/setup-apollo.sh"
          exit 0
        else
          log_error "setup-apollo.sh not found at $SCRIPT_DIR/setup-apollo.sh"
          exit 1
        fi
        ;;
      -*)
        log_error "Unknown option: $1"
        echo ""
        show_help
        exit 1
        ;;
      *)
        # For backward compatibility, treat positional args as question in headless mode
        if [ -z "$question" ]; then
          # Check if it's a management command
          if [ "$1" = "consolidate" ] || [ "$1" = "audit" ]; then
            mode="management"
            question="$1"
          else
            mode="headless"
            question="$*"
          fi
        fi
        break
        ;;
    esac
  done

  # Route based on mode
  case "$mode" in
    menu)
      menu_mode
      ;;
    interactive)
      check_env
      load_env
      test_ssh_connection
      test_agent_availability
      interactive_mode
      ;;
    headless)
      if [ -z "$question" ]; then
        log_error "No question provided for headless mode"
        exit 1
      fi
      headless_mode "$question"
      ;;
    download-interactions)
      check_env
      load_env
      test_ssh_connection
      download_interactions
      exit 0
      ;;
    download-memories)
      check_env
      load_env
      test_ssh_connection
      download_all_memories
      exit 0
      ;;
    recent)
      check_env
      load_env
      test_ssh_connection
      view_recent_interactions
      exit 0
      ;;
    management)
      check_env
      load_env
      test_ssh_connection
      test_agent_availability
      echo ""
      if [ "$question" = "consolidate" ]; then
        log_info "Running memory consolidation (may take 30-60 seconds)..."
      elif [ "$question" = "audit" ]; then
        log_info "Auditing identity drift..."
      fi
      echo ""
      send_to_agent "" "$question"
      echo ""
      exit 0
      ;;
  esac
}

# Run main
main "$@"
